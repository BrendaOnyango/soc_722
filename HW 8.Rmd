---
title: "HW 8_Onyango"
author: "Brenda Onyango"
date: "10/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load needed packages 

```{r}
library(tidyverse)
library(janitor)
library(rstan)
library(bayesplot)
```

## Exercise 1 

a) The steps for grid approximation are: 
1) Define a discrete grid of possible theta values 
2) evaluate the prior pdf of f(theta) and liklihood function L(theta|y) at each theta grid value
3)Calculate the product of f(theta) * L(theta|y) at each theta grid value and then normalize the products so they sum to 1
4) randomly sample N theta grid values 

b) To make the approximation more accurate I would change the first step when defining a discrete grid. Increasing the number of grid values creates approximations that better match true posteriors. 

## Exercise 2 

```{r}
#Using code Yue shared to include picture

knitr::include_graphics("/Users/brendaonyango/Desktop/IMG_4318 copy.png")
```

## Exercise 3 

a) If the chain is mixing too slowly it will have only explored a limited range in the first several thousands iterations. It will overestimate the plausibility of pi values in this range and underestimate the plasuibility of values outside the range. 

b) The chain having a high correlation will not estimate the correct peak, if there is one, in the posterior. 

c) Chains that get stuck are overestimating in the values where they are stuck and will produce peaks in the posterior that are not there. 

## Exercise 6.4 

a) MCMC diagnostics are important because simulations are not perfect and diagnostics, used holistically, can identify how to improve a MCMC chain.

b) MCMC simulations are helpful because they are an efficient and flexible alternative to grid approximations. Grid approximations for more complex problems take a long time and grid approximations are not good for estimating posteriors when there are multiple dimensions. MCMCs can. 

c) Rstan combines R with the Stan "engine"; Stan is written in C++ and is good for Bayesian modeling. 

d) How to put Markov chains in applied language for social problems/questions. 

## Exercise 6.5

We're given Y|pi~Bin(n, pi) and pi~Beta(3, 8) and n = 10 with Y = 2.

a) Use grid approximation with values pi E{0, 0.25, 0.50, .75,1} to approximate posterior

```{r}
#step 1: defining a grid with 5 pi values 
grid_data <- data.frame(pi_grid = seq(from = 0, to = 1, length = 5))

# step 2: evaluating prior and liklihood at each pi
grid_data <- grid_data |> 
  mutate(prior = dbeta(pi_grid, 3,8), 
         liklihood =dbinom(2,10, pi_grid))
```

Next is approximating the posterior using the product of the liklihood and prior and then normalizing them. 

```{r}
#step 3: approximate the posterior
grid_data <- grid_data |> 
  mutate(unnormalized = liklihood * prior, 
         posterior = unnormalized/sum(unnormalized))

#confirming that posterior approximation sums to 1
grid_data |> summarize(sum(unnormalized), sum(posterior))
```
Next we'll examine the grid approxiation posterior rounded to 2 decimal places. 
```{r}
#step 4
round(grid_data, 2) #2 is indicating how many decimal points to use 
```

Finally, we'll plot this model. 
```{r}
# plotting the grid approximation posterior
ggplot(grid_data, aes(x = pi_grid, y = posterior)) + 
  geom_point() + 
  geom_segment(aes(x = pi_grid, xend = pi_grid, y = 0, yend = posterior))
```

b) Now we're asked to repeat the above using a grid of 201 equally spaced values between 0 and 1. 

```{r}
#step 1
grd_data <- data.frame(p_grid = seq(from = 0, to = 1, length = 201)) #changed length to 201

#step 2
grd_data <- grd_data |> #changed names of data, prior, liklihood to keep distinct from part a 
  mutate(prir = dbeta(p_grid, 3,8), #prior remained the same 
         liklhood = dbinom(2,10, p_grid)) #successes and outcomes remained teh same
#step 3
grd_data <- grd_data |> 
  mutate(unnormalized = liklhood * prir, 
         posterir = unnormalized/sum(unnormalized))

#confirming that posterior approximation sums to 1
grd_data |> summarize(sum(unnormalized), sum(posterir))

#step 4
round(grd_data, 2)


```

Next I'll plot this approximation. 

```{r}
ggplot(grd_data, aes(x = p_grid, y = posterir)) + 
  geom_point() + 
  geom_segment(aes(x = p_grid, xend = p_grid, y = 0, yend = posterir))
```

We can see that b gives a much better estimate than a. 

## Exercise 6.6

We're given a Gamma-Poison model for Y|lambda~Pois(lambda) and lambda~Gamma(20,5). N = 3 and (Y1, Y2, Y3) = (0, 1, 0).

a) Use grid approximation with values E{0, 1, 2,...8} to approximate posterior model lambda. 

```{r}
# Step 1: Define a grid of 10 lambda values
grid_data   <- data.frame(lambda_grid = seq(from = 0, to = 8, length = 8)) 

# Step 2: Evaluate the prior & likelihood at each lambda
grid_data <- grid_data |> 
  mutate(prior = dgamma(lambda_grid, 20, 5), #given prior
         likelihood = dpois(0, lambda_grid) * dpois(1, lambda_grid) * dpois(0, lambda_grid))

# Step 3: Approximate the posterior
grid_data <- grid_data |> 
  mutate(unnormalized = likelihood * prior,
         posterior = unnormalized / sum(unnormalized))

# Set the seed
set.seed(1500)

# Step 4: sample from the discretized posterior
post_sample <- sample_n(grid_data, size = 10000, 
                        weight = posterior, replace = TRUE)

#plotting histogram of the above 

ggplot(post_sample, aes(x = lambda_grid)) + 
  geom_histogram(aes(y = ..density..), color = "white") + 
  stat_function(fun = dgamma, args = list(20, 5)) + 
  lims(x = c(0, 8))
```


b) Repeat the above using a grid of 201 with equally spaced values between 0 & 8. 

```{r}
# Step 1: Define a grid of 10 lambda values
grid_data   <- data.frame(lambda_grid = seq(from = 0, to = 8, length = 201)) # went up to 10 values to see what happens after 8

# Step 2: Evaluate the prior & likelihood at each lambda
grid_data <- grid_data |> 
  mutate(prior = dgamma(lambda_grid, 20, 5), #given prior
         likelihood = dpois(0, lambda_grid) * dpois(1, lambda_grid) * dpois(0, lambda_grid))

# Step 3: Approximate the posterior
grid_data <- grid_data |> 
  mutate(unnormalized = likelihood * prior,
         posterior = unnormalized / sum(unnormalized))

# Set the seed
set.seed(1500)

# Step 4: sample from the discretized posterior
post_sample <- sample_n(grid_data, size = 10000, 
                        weight = posterior, replace = TRUE)

#plotting histogram of the above 

ggplot(post_sample, aes(x = lambda_grid)) + 
  geom_histogram(aes(y = ..density..), color = "white") + 
  stat_function(fun = dgamma, args = list(20, 5)) + 
  lims(x = c(0, 8))
```
## Exercise 6.7 

We're given a normal-normal model for mu with Y|mu~N(mu, 1.3^2) and mu~N(10,1.2^2). Observed data is (Y1, Y2, Y3, Y4) = (7.1, 8.9, 8.4, 8.6)

```{r}
# Step 1: Define a grid of 50 mu values
grid_data  <- data.frame(mu_grid = seq(from = 7, to = 10, length = 50)) #narrowed the sequence range 
#changed to 50 values to demonstrate that I know as grid spacing decreases, quality of approximation decreases 

# Step 2: Evaluate the prior & likelihood at each mu
grid_data <- grid_data |> 
  mutate(prior = dnorm(mu_grid, mean = 10, sd = 1.2), 
         likelihood = dnorm(7.1, mean = mu_grid, sd = 1.3)*
           dnorm(8.9, mean = mu_grid, sd = 1.3)* 
           dnorm(8.4, mean = mu_grid, sd = 1.3)* 
           dnorm(8.6, mean = mu_grid, sd = 1.3))


# Step 3: Approximate the posterior
grid_data <- grid_data |>  
  mutate(unnormalized = likelihood * prior,
         posterior = unnormalized / sum(unnormalized))

ggplot(grid_data, aes(x = mu_grid, y = posterior)) + 
  geom_point() + 
  geom_segment(aes(x = mu_grid, xend = mu_grid, y = 0, yend = posterior))
```

b) Repeat the above using a grid of 201 equally spaced values b/w 5 and 15. 
```{r}
# Step 1: Define a grid of 201 mu values
grid_data  <- data.frame(mu_grid = seq(from = 5, to = 15, length = 201)) 

# Step 2: Evaluate the prior & likelihood at each mu
grid_data <- grid_data |> 
  mutate(prior = dnorm(mu_grid, mean = 10, sd = 1.2), 
         likelihood = dnorm(7.1, mean = mu_grid, sd = 1.3)*
           dnorm(8.9, mean = mu_grid, sd = 1.3)* 
           dnorm(8.4, mean = mu_grid, sd = 1.3)* 
           dnorm(8.6, mean = mu_grid, sd = 1.3))


# Step 3: Approximate the posterior
grid_data <- grid_data |>  
  mutate(unnormalized = likelihood * prior,
         posterior = unnormalized / sum(unnormalized))

ggplot(grid_data, aes(x = mu_grid, y = posterior)) + 
  geom_point() + 
  geom_segment(aes(x = mu_grid, xend = mu_grid, y = 0, yend = posterior))
```


## Exercise 6.9
a) The drawback of grid approximation is ineffiency for estimating large,scale 
